# Phase 1: Electron Foundation - Research

**Researched:** 2026-01-19
**Domain:** Electron desktop application with Next.js integration
**Confidence:** HIGH

## Summary

Phase 1 requires establishing Electron as a desktop wrapper for an existing Next.js application, with IPC (Inter-Process Communication) bridge for SQLite access and native application menus. Research confirms that Electron + Next.js is a mature pattern with multiple integration approaches. The standard approach uses Electron Forge for packaging, with webpack plugin for development workflow (hot reload, bundling). IPC security is critical: context isolation must be enabled, preload scripts must expose limited APIs via contextBridge, and all IPC messages must validate sender. better-sqlite3 runs in main process only, accessible via IPC handlers. Application menus use Electron's Menu.buildFromTemplate with roles for native behavior.

**Primary recommendation:** Use Electron Forge with webpack plugin for packaging and development, implement IPC with contextBridge pattern for security, and use Menu.buildFromTemplate with standard roles for cross-platform menus.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| electron | Latest LTS | Desktop app framework | Official framework, mature ecosystem |
| @electron-forge/cli | Latest | Packaging and distribution | Official tool, unified workflow |
| @electron-forge/plugin-webpack | Latest | Development tooling (HMR, bundling) | Standard for Electron + webpack, built-in HMR |
| better-sqlite3 | Latest | SQLite database in main process | Synchronous API, Electron-compatible |
| electron-is-dev | Latest | Development/production detection | Standard env detection pattern |

### Development Tools
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| webpack | 5.x | Bundling main and renderer processes | Required by Forge webpack plugin |
| webpack-dev-server | Latest | HMR for renderer process | Built-in with Forge plugin |
| node-loader | Latest | Native Node modules support | For better-sqlite3 compatibility |
| @vercel/webpack-asset-relocator-loader | Pinned version | Native module asset handling | Required for Electron compatibility |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Electron Forge | electron-builder | Forge is official tool, simpler config; builder has more customization options |
| Electron Forge webpack plugin | electron-vite | Vite is faster but less mature for Electron; webpack is standard, better documentation |
| Manual IPC bridge | nextron | Nextron is opinionated template; manual approach gives more control, lighter |

**Installation:**
```bash
npm install --save-dev electron @electron-forge/cli @electron-forge/plugin-webpack
npm install better-sqlite3 electron-is-dev
npx electron-forge import
```

## Architecture Patterns

### Recommended Project Structure
```
project-root/
├── main/               # Electron main process
│   ├── index.js        # Entry point
│   ├── ipc/            # IPC handlers
│   │   └── handlers.js # Database operations, etc.
│   └── menu.js         # Application menu configuration
├── preload/            # Preload scripts
│   └── index.js        # Expose APIs via contextBridge
├── .webpack/           # Generated by Forge (DO NOT EDIT)
├── forge.config.js     # Electron Forge configuration
├── webpack.main.config.js    # Main process webpack config
├── webpack.renderer.config.js # Renderer process webpack config
└── package.json        # Entry: "./.webpack/main"
```

### Pattern 1: Electron + Next.js Integration
**What:** Load Next.js dev server in development, bundled build in production
**When to use:** When you have existing Next.js app to package as desktop
**Example:**
```javascript
// main/index.js (Main Process)
const { app, BrowserWindow } = require('electron');
const path = require('path');
const isDev = require('electron-is-dev');

function createWindow() {
  const mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      preload: path.join(__dirname, '../preload/index.js'),
      contextIsolation: true,
      nodeIntegration: false
    }
  });

  if (isDev) {
    // Load Next.js dev server
    mainWindow.loadURL('http://localhost:3000');
    mainWindow.webContents.openDevTools();
  } else {
    // Load production build (packaged with app)
    mainWindow.loadFile(path.join(__dirname, '../renderer/index.html'));
  }
}

app.whenReady().then(createWindow);
```

### Pattern 2: IPC Bridge for SQLite Access
**What:** Two-way IPC using ipcMain.handle and ipcRenderer.invoke
**When to use:** When renderer needs to access main process resources (database, fs)
**Example:**
```javascript
// main/ipc/handlers.js (Main Process)
const { ipcMain } = require('electron');
const Database = require('better-sqlite3');
const path = require('path');

const db = new Database(path.join(app.getPath('userData'), 'annotations.db'));

// Initialize database schema
db.exec(`
  CREATE TABLE IF NOT EXISTS annotations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    type TEXT NOT NULL,
    text TEXT NOT NULL,
    position TEXT NOT NULL,
    note TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  )
`);

// Expose database operations via IPC
ipcMain.handle('db:addAnnotation', (event, { type, text, position, note }) => {
  const stmt = db.prepare('INSERT INTO annotations (type, text, position, note) VALUES (?, ?, ?, ?)');
  return stmt.run(type, text, position, note);
});

ipcMain.handle('db:getAnnotations', () => {
  return db.prepare('SELECT * FROM annotations').all();
});
```

```javascript
// preload/index.js (Preload Script)
const { contextBridge, ipcRenderer } = require('electron');

contextBridge.exposeInMainWorld('electronAPI', {
  addAnnotation: (data) => ipcRenderer.invoke('db:addAnnotation', data),
  getAnnotations: () => ipcRenderer.invoke('db:getAnnotations')
});
```

```javascript
// Renderer Process (Next.js/React)
const annotations = await window.electronAPI.getAnnotations();
await window.electronAPI.addAnnotation({
  type: 'highlight',
  text: 'Selected text',
  position: '{"page": 1, "rect": {...}}',
  note: 'User note here'
});
```

### Pattern 3: Application Menu with Roles
**What:** Use Menu.buildFromTemplate with standard roles
**When to use:** For cross-platform native menus
**Example:**
```javascript
// main/menu.js (Main Process)
const { app, Menu } = require('electron');

const isMac = process.platform === 'darwin';

const template = [
  // App menu (macOS only)
  ...(isMac ? [{
    label: app.name,
    submenu: [
      { role: 'about' },
      { type: 'separator' },
      { role: 'hide' },
      { role: 'hideOthers' },
      { role: 'unhide' },
      { type: 'separator' },
      { role: 'quit' }
    ]
  }] : []),
  // File menu
  {
    label: 'File',
    submenu: [
      isMac ? { role: 'close' } : { role: 'quit' }
    ]
  },
  // Edit menu
  {
    label: 'Edit',
    submenu: [
      { role: 'undo' },
      { role: 'redo' },
      { type: 'separator' },
      { role: 'cut' },
      { role: 'copy' },
      { role: 'paste' },
      { role: 'selectAll' }
    ]
  },
  // View menu
  {
    label: 'View',
    submenu: [
      { role: 'reload' },
      { role: 'forceReload' },
      { role: 'toggleDevTools' },
      { type: 'separator' },
      { role: 'resetZoom' },
      { role: 'zoomIn' },
      { role: 'zoomOut' },
      { type: 'separator' },
      { role: 'togglefullscreen' }
    ]
  },
  // Help menu
  {
    label: 'Help',
    submenu: [
      {
        label: 'Learn More',
        click: async () => {
          const { shell } = require('electron');
          await shell.openExternal('https://electronjs.org');
        }
      }
    ]
  }
];

const menu = Menu.buildFromTemplate(template);
Menu.setApplicationMenu(menu);
```

### Anti-Patterns to Avoid
- **Disabling contextIsolation:** Severe security risk. Always enable contextIsolation.
- **Exposing raw ipcRenderer to renderer:** Use contextBridge to expose only specific APIs.
- **Using nodeIntegration in renderer:** Deprecated, insecure. Use preload scripts instead.
- **Synchronous IPC (ipcRenderer.sendSync):** Blocks renderer process. Use ipcRenderer.invoke instead.
- **Loading remote content with Node.js integration:** RCE risk. Only load local content with nodeIntegration.
- **Validating IPC messages without checking sender:** Must validate event.sender for all IPC handlers.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| IPC hot reload | Custom file watching + IPC reload | Electron Forge webpack plugin | Built-in HMR for renderer, rs command for main process restart |
| Packaging Electron app | Manual electron-packager config | Electron Forge | Unified toolchain, handles packaging + making distributables |
| Menu accelerators | Manual keyboard event handling | Menu role accelerators | Cross-platform, native OS integration, automatic localization |
| Process detection | Custom env variables | electron-is-dev | Standard pattern, handles edge cases |
| Native module loading | Manual .node file loading | node-loader + asset relocator | Handles Electron's native module ABI requirements |

**Key insight:** Electron's webpack plugin generates magic global variables (MAIN_WINDOW_WEBPACK_ENTRY, MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY) that handle dev/production path differences automatically. Hand-rolling this breaks in production.

## Common Pitfalls

### Pitfall 1: Loading Next.js in Electron
**What goes wrong:** Loading Next.js dev server works but production build fails with "file not found" errors
**Why it happens:** Different URLs in dev (http://localhost:3000) vs production (file:// path). Hardcoded paths don't work.
**How to avoid:**
- Use electron-is-dev to detect environment
- In dev: loadURL to Next.js dev server
- In prod: loadFile to packaged Next.js export
- Use Forge's webpack plugin magic globals for preload paths
**Warning signs:** "ERR_FILE_NOT_FOUND" in production console, works in dev only

### Pitfall 2: IPC Security - Exposed APIs
**What goes wrong:** Renderer can access any IPC channel, escalate privileges
**Why it happens:** Directly exposing ipcRenderer or using wildcard IPC listeners
**How to avoid:**
- Always use contextBridge.exposeInMainWorld with specific APIs
- Never pass raw ipcRenderer callbacks (exposes event.sender)
- Validate sender in all ipcMain handlers using event.senderFrame.url
- Use strict IPC channel naming (e.g., 'db:getAnnotations' not 'getData')
**Warning signs:** Global window.ipcRenderer or window.electron with full API access

### Pitfall 3: better-sqlite3 in Renderer
**What goes wrong:** "Cannot read property 'handle' of undefined" or module not found
**Why it happens:** better-sqlite3 requires native Node.js bindings, only available in main process
**How to avoid:**
- Run better-sqlite3 ONLY in main process
- Expose database operations via IPC handlers (ipcMain.handle)
- Call from renderer via ipcRenderer.invoke through contextBridge
**Warning signs:** Trying to require('better-sqlite3') in renderer or Next.js code

### Pitfall 4: Electron Forge Configuration
**What goes wrong:** "Cannot find module './.webpack/main'" or HMR not working
**Why it happens:** package.json main entry not updated to './.webpack/main', or incorrect webpack config paths
**How to avoid:**
- Set "main": "./.webpack/main" in package.json
- Use magic globals: MAIN_WINDOW_WEBPACK_ENTRY, MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY
- Ensure webpack.main.config.js and webpack.renderer.config.js exist
- Configure entryPoints correctly in forge.config.js
**Warning signs:** Entry point errors, HMR not refreshing, preload script not loading

### Pitfall 5: Menu Platform Differences
**What goes wrong:** Menu appears in wrong location or missing items on macOS vs Windows
**Why it happens:** macOS has app menu in menu bar, Windows puts app menu in window
**How to avoid:**
- Use Menu.buildFromTemplate with roles (not custom click handlers)
- Conditionally add app menu for macOS (process.platform === 'darwin')
- Use role: 'about', role: 'quit' instead of custom implementations
- Test on all target platforms early
**Warning signs:** Menu items in wrong location, keyboard shortcuts don't work

### Pitfall 6: CSP Violations in Development
**What goes wrong:** DevTools shows CSP errors, scripts blocked
**Why it happens:** Electron's webSecurity enabled by default, inline scripts or eval blocked
**How to avoid:**
- Define appropriate CSP meta tag: <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-eval'">
- Use 'unsafe-eval' for source maps in dev only
- Never use 'unsafe-inline' or wildcard (*) in production
- Load external scripts via HTTPS only
**Warning signs:** Refused to load inline script, CSP violations in console

## Code Examples

Verified patterns from official sources:

### Basic Electron Window with Next.js
```javascript
// Source: Electron Quick Start docs + Forge webpack plugin
const { app, BrowserWindow } = require('electron');
const path = require('path');

function createWindow() {
  const win = new BrowserWindow({
    width: 800,
    height: 600,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY, // Magic global from Forge
      contextIsolation: true,
      nodeIntegration: false
    }
  });

  win.loadURL(MAIN_WINDOW_WEBPACK_ENTRY); // Magic global from Forge
}

app.whenReady().then(() => {
  createWindow();

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) createWindow();
  });
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') app.quit();
});
```

### Secure IPC Pattern
```javascript
// Source: Electron IPC docs + Security checklist
// Main Process
const { ipcMain } = require('electron');

ipcMain.handle('db:query', (event, sql) => {
  // Validate sender
  if (!validateSender(event.senderFrame)) {
    console.warn('Unauthorized IPC sender:', event.senderFrame.url);
    return null;
  }

  // Execute query
  try {
    return db.prepare(sql).all();
  } catch (error) {
    // Forward error to renderer for debugging
    throw new Error(`Database error: ${error.message}`);
  }
});

function validateSender(frame) {
  // Only allow messages from app's origin
  const allowedOrigins = [app.getAppPath(), 'http://localhost:3000'];
  return allowedOrigins.some(origin => frame.url.startsWith(origin));
}
```

```javascript
// Preload Script
const { contextBridge, ipcRenderer } = require('electron');

contextBridge.exposeInMainWorld('electronAPI', {
  // Good: Expose specific API with validation
  queryDatabase: (sql) => ipcRenderer.invoke('db:query', sql)
});

// Bad: Exposing raw ipcRenderer
contextBridge.exposeInMainWorld('electron', {
  ipcRenderer: ipcRenderer // NEVER DO THIS - full IPC access
});

// Bad: Passing callback directly (exposes event.sender)
contextBridge.exposeInMainWorld('electronAPI', {
  onUpdateCounter: (callback) => ipcRenderer.on('update-counter', callback) // Event object leaks
});
```

### Forge Configuration with Webpack
```javascript
// Source: Electron Forge webpack plugin docs
// forge.config.js
module.exports = {
  packagerConfig: {},
  rebuildConfig: {},
  makers: [
    {
      name: '@electron-forge/maker-squirrel',
      config: {}
    },
    {
      name: '@electron-forge/maker-zip',
      platforms: ['darwin']
    },
    {
      name: '@electron-forge/maker-deb',
      config: {}
    }
  ],
  plugins: [
    {
      name: '@electron-forge/plugin-webpack',
      config: {
        mainConfig: './webpack.main.config.js',
        renderer: {
          config: './webpack.renderer.config.js',
          entryPoints: [
            {
              name: 'main_window',
              html: './src/renderer/index.html',
              js: './src/renderer/index.js',
              preload: {
                js: './src/preload.js'
              }
            }
          ]
        }
      }
    }
  ]
};
```

### Webpack Main Config
```javascript
// webpack.main.config.js
module.exports = {
  mode: process.env.NODE_ENV || 'development',
  target: 'electron-main',
  node: {
    __dirname: false,
    __filename: false
  },
  entry: './main/index.js',
  output: {
    path: __dirname + '/.webpack',
    filename: 'main/[name].js'
  },
  module: {
    rules: [
      {
        test: /\.node$/,
        use: 'node-loader'
      },
      {
        test: /\.(m?js|node)$/,
        parser: { amd: false },
        use: {
          loader: '@vercel/webpack-asset-relocator-loader',
          options: {
            outputAssetBase: 'native_modules'
          }
        }
      }
    ]
  }
};
```

### Webpack Renderer Config
```javascript
// webpack.renderer.config.js
const path = require('path');

module.exports = {
  mode: process.env.NODE_ENV || 'development',
  target: 'web', // Use 'web' for Next.js integration (nodeIntegration: false)
  entry: './src/renderer/index.js',
  output: {
    path: __dirname + '/.webpack',
    filename: 'renderer/[name].js'
  },
  devServer: {
    static: {
      directory: path.join(__dirname, 'src/renderer')
    },
    hot: true
  }
};
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| electron-packager + electron-builder setup | Electron Forge unified toolchain | Forge v6+ (2021) | Single tool for dev + packaging, less config complexity |
| Manual IPC security implementation | contextBridge + context isolation defaults | Electron 12+ (2021) | Secure by default, cannot accidentally disable |
| Webpack 4 with custom config | Webpack 5 with built-in asset relocation | Webpack 5 (2020) | No need for externals config, better native module support |
| nodeIntegration: true default | nodeIntegration: false default | Electron 5+ (2019) | Secure by default, renderer has no Node.js access |
| Manual hot reload setup | Forge webpack plugin HMR | Forge plugin (2020) | Built-in HMR for renderer, 'rs' command for main process |

**Deprecated/outdated:**
- **nextron**: Opinionated template, less flexible than manual setup. Forge + webpack is standard.
- **electron-react-boilerplate**: Outdated patterns, uses deprecated webpack configs.
- **electron-vite**: Promising but less mature than Forge webpack plugin (as of 2025).
- **ipcRenderer.sendSync**: Blocks renderer, deprecated. Use ipcRenderer.invoke for two-way IPC.
- **nodeIntegration in renderer**: Security risk, disabled by default since Electron 5. Use preload scripts.

## Open Questions

Things that couldn't be fully resolved:

1. **Electron Forge vs electron-vite for Next.js in 2025**
   - What we know: electron-vite is faster (Vite-based) but newer; Forge webpack plugin is standard
   - What's unclear: Long-term maintenance of electron-vite, Next.js + Vite compatibility issues
   - Recommendation: Stick with Forge webpack plugin for stability; evaluate electron-vite for Phase 2 if build times are problematic

2. **Next.js App Router with Electron specific issues**
   - What we know: App Router works with Electron; need to load dev server or static export
   - What's unclear: Server Actions in Electron context, API routes vs IPC bridge overlap
   - Recommendation: Use Next.js static export (output: 'export') for Phase 1; investigate Server Actions in Phase 2

3. **Main process hot reload tooling**
   - What we know: Forge webpack plugin supports 'rs' command for main process restart
   - What's unclear: Whether esbuild-based tools provide faster rebuild than webpack for main process
   - Recommendation: Use Forge's built-in 'rs' command for Phase 1; evaluate esbuild integration if main process rebuild is slow

## Sources

### Primary (HIGH confidence)
- [Electron Official IPC Documentation](https://www.electronjs.org/docs/latest/tutorial/ipc) - Verified IPC patterns, contextBridge usage
- [Electron Official Security Guidelines](https://www.electronjs.org/docs/latest/tutorial/security) - Security checklist, IPC validation
- [Electron Official Quick Start](https://www.electronjs.org/docs/latest/tutorial/quick-start) - Basic Electron app structure
- [Electron Official Menus Tutorial](https://www.electronjs.org/docs/latest/tutorial/menus) - Menu API, roles, cross-platform patterns
- [Electron Forge Webpack Plugin](https://www.electronforge.io/config/plugins/webpack) - Forge configuration, magic globals, HMR setup

### Secondary (MEDIUM confidence)
- [How to Build an Electron App with Next.js: A Complete Guide](https://medium.com/@aleksej.gudkov/how-to-build-an-electron-app-with-next-js-a-complete-guide-6f6ddf0111b2) - Next.js + Electron integration patterns
- [Building Desktop Apps with Electron + Next.JS (without Nextron)](https://rbfraphael.medium.com/building-desktop-apps-with-electron-next-js-without-nextron-01bbf1fdd72e) - Step-by-step setup guide
- [How to Set Up Next.js with Electron in 2025 | Full Tutorial](https://www.youtube.com/watch?v=2rh8p74kp70) - Latest video tutorial (2025)
- [Electron+nextjs+Electron_Forge跨端平台方案](https://blog.csdn.net/cf8833/article/details/146581127) - March 2025 Chinese article on Forge + Next.js
- [Electron Forge vs electron-builder Reddit Discussion](https://www.reddit.com/r/electronjs/comments/1hd70zu/forge_vs_builder_as_new_electron_dev/) - Community comparison
- [Best way to start an electron app (2025)?](https://www.reddit.com/r/electronjs/comments/1lrvtp7/best_way_to_start_an_electron_app_2025/) - 2025 tooling discussion
- [A Step-by-Step Guide to Integrating Better-SQLite3](https://dev.to/arindam1997007/a-step-by-step-guide-to-integrating-better-sqlite3-with-electron-js-app-using-create-react-app-3k16) - better-sqlite3 + Electron integration
- [CVE-2025-67744: Critical RCE in DeepChat](https://www.thehackerwire.com/cve-2025-67744-critical-rce-in-deepchat-via-mermaid-xss-and-exposed-electron-ipc/) - Recent IPC security vulnerability (2025)
- [The Risks of Misusing Electron IPC](https://codiewhitaker.medium.com/enhancing-electron-ipc-b8c731dfedae) - IPC security best practices

### Tertiary (LOW confidence)
- [electron.vite + better-sqlite3 Complete Tutorial](https://blog.csdn.net/weixin_44402520/article/details/145907685) - March 2025 Chinese article (electron-vite not yet verified)
- [Electron-vite Official Docs](https://electron-vite.org/guide/) - Alternative to Forge (needs verification for production use)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Based on official Electron Forge documentation
- Architecture: HIGH - Based on official Electron IPC, Security, and Menu docs
- Pitfalls: HIGH - Based on official security checklist and CVE reports
- Next.js integration: MEDIUM - WebSearch verified with Medium articles, no official docs
- electron-vite: LOW - Single source, needs validation before recommending

**Research date:** 2026-01-19
**Valid until:** 2026-02-18 (30 days - Electron and Forge are stable, but Next.js integration patterns evolve)

---

*Research completed for Phase 1: Electron Foundation*
*Sources include official Electron documentation (v34.0.0+) and 2025 community resources*
