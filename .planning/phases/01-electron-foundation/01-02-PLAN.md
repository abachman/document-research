---
phase: 01-electron-foundation
plan: 02
type: execute
wave: 2
depends_on: [01-01]
files_modified: [main/ipc/handlers.js, main/ipc/database.js, preload/index.js, app/lib/electron.ts, .gitignore]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Renderer process can invoke main process operations via IPC"
    - "SQLite database accessible from renderer through IPC bridge"
    - "IPC handlers validate sender for security"
    - "ContextBridge exposes limited, typed API surface"
  artifacts:
    - path: "main/ipc/handlers.js"
      provides: "IPC channel handlers for database operations"
      min_lines: 40
      contains: ["ipcMain.handle", "validateSender"]
    - path: "main/ipc/database.js"
      provides: "SQLite database initialization and operations"
      min_lines: 30
      contains: ["Database", "better-sqlite3", "app.getPath('userData')"]
    - path: "preload/index.js"
      provides: "contextBridge-exposed electronAPI"
      contains: ["db:query", "db:exec"]
    - path: "app/lib/electron.ts"
      provides: "TypeScript types for electronAPI"
      min_lines: 15
      contains: ["interface ElectronAPI"]
  key_links:
    - from: "app/lib/electron.ts"
      to: "main/ipc/handlers.js"
      via: "ipcRenderer.invoke in preload"
      pattern: "ipcRenderer\\.invoke\\('db:"
    - from: "main/ipc/handlers.js"
      to: "main/ipc/database.js"
      via: "Database operations"
      pattern: "db\\.prepare|db\\.exec"
---

<objective>
Implement IPC bridge enabling Next.js renderer process to access SQLite database in Electron main process, with secure contextBridge pattern and sender validation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-electron-foundation/01-RESEARCH.md
@.planning/phases/01-electron-foundation/01-01-SUMMARY.md
@main/index.js
@preload/index.js
</context>

<tasks>

<task type="auto">
  <name>Create SQLite database module</name>
  <files>main/ipc/database.js</files>
  <action>
    Create main/ipc/database.js with:
    - Import better-sqlite3 and electron app
    - Initialize Database at app.getPath('userData')/annotations.db
    - Create function initializeSchema():
      * Create annotations table if not exists:
        - id INTEGER PRIMARY KEY AUTOINCREMENT
        - type TEXT NOT NULL (for 'highlight' or 'note')
        - text TEXT NOT NULL
        - position TEXT NOT NULL (JSON string)
        - note TEXT (optional, for user's note)
        - created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      * Create documents table if not exists (for Phase 3):
        - id INTEGER PRIMARY KEY AUTOINCREMENT
        - filename TEXT NOT NULL
        - filepath TEXT NOT NULL
        - title TEXT
        - created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    - Export db instance and initializeSchema function

    Follow RESEARCH.md "Pattern 2: IPC Bridge for SQLite Access"
  </action>
  <verify>main/ipc/database.js exists with Database initialization and schema creation</verify>
  <done>SQLite database module created with annotations and documents tables</done>
</task>

<task type="auto">
  <name>Create IPC handlers with sender validation</name>
  <files>main/ipc/handlers.js</files>
  <action>
    Create main/ipc/handlers.js with:
    - Import ipcMain and app from electron
    - Import db from ./database.js
    - Create validateSender(frame) function:
      * Check frame.url against allowed origins
      * Allowed: app.getAppPath() (local files), http://localhost:3000 (dev server)
      * Return true if allowed, false otherwise
      * Log warning if unauthorized
    - Register IPC handlers:
      * 'db:exec': Execute SQL statement (INSERT, UPDATE, DELETE)
        - Validate sender
        - Run db.prepare(sql).run(params)
        - Return lastInsertRowid or changes
      * 'db:query': Execute SELECT query
        - Validate sender
        - Run db.prepare(sql).all(params)
        - Return results array
      * 'db:init': Initialize database schema
        - Call initializeSchema()
        - Return success message
    - Export registerHandlers function to call from main/index.js

    Follow RESEARCH.md "Secure IPC Pattern" and "Pattern 2: IPC Bridge"
  </action>
  <verify>main/ipc/handlers.js exists with validateSender and db:* IPC handlers</verify>
  <done>Secure IPC handlers created with sender validation</done>
</task>

<task type="auto">
  <name>Register IPC handlers in main process</name>
  <files>main/index.js</files>
  <action>
    Modify main/index.js:
    - Import registerHandlers from './ipc/handlers.js'
    - After app.whenReady(), call registerHandlers()
    - This sets up all IPC channels before window creation

    Ensure handlers are registered before any renderer loads.
  </action>
  <verify>main/index.js imports and calls registerHandlers()</verify>
  <done>IPC handlers registered at application startup</done>
</task>

<task type="auto">
  <name>Update preload script with IPC methods</name>
  <files>preload/index.js</files>
  <action>
    Modify preload/index.js:
    - Replace empty electronAPI object with database methods:
      * queryDatabase: (sql: string, params: any[]) => ipcRenderer.invoke('db:query', sql, params)
      * execDatabase: (sql: string, params: any[]) => ipcRenderer.invoke('db:exec', sql, params)
      * initDatabase: () => ipcRenderer.invoke('db:init')
    - Use TypeScript-like JSDoc comments for type hints:
      * @param {string} sql - SQL statement
      * @param {any[]} params - Query parameters
      * @returns {Promise<any>}

    Follow RESEARCH.md security pattern: expose ONLY specific methods, not raw ipcRenderer.
  </action>
  <verify>preload/index.js exposes queryDatabase, execDatabase, initDatabase via contextBridge</verify>
  <done>Secure IPC bridge exposed to renderer via contextBridge</done>
</task>

<task type="auto">
  <name>Create TypeScript types for electronAPI</name>
  <files>app/lib/electron.ts</files>
  <action>
    Create app/lib/electron.ts with:
    - Declare global interface Window augmentation:
      ```typescript
      interface ElectronAPI {
        queryDatabase: (sql: string, params?: any[]) => Promise<any[]>;
        execDatabase: (sql: string, params?: any[]) => Promise<{ lastInsertRowid: number; changes: number }>;
        initDatabase: () => Promise<string>;
      }

      declare global {
        interface Window {
          electronAPI: ElectronAPI;
        }
      }

      export {};
      ```
    - This provides TypeScript autocomplete and type safety
    - Include JSDoc comments for documentation

    File should be .ts (not .tsx) since it's not a React component.
  </action>
  <verify>app/lib/electron.ts exists with ElectronAPI interface</verify>
  <done>TypeScript types defined for electronAPI</done>
</task>

<task type="auto">
  <name>Update .gitignore for database</name>
  <files>.gitignore</files>
  <action>
    Add to .gitignore:
    - *.db (SQLite database files)
    - *.db-shm (SQLite shared-memory files)
    - *.db-wal (SQLite write-ahead log files)

    User data directory should not be committed to git.
  </action>
  <verify>.gitignore contains *.db, *.db-shm, *.db-wal entries</verify>
  <done>Database files excluded from git</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>IPC bridge with SQLite database integration</what-built>
  <how-to-verify>
    1. Create test file app/electron-ipc-test.tsx:
       ```tsx
       'use client';

       export default function IPCTest() {
         const testIPC = async () => {
           try {
             await window.electronAPI.initDatabase();
             console.log('Database initialized');

             // Insert test annotation
             await window.electronAPI.execDatabase(
               'INSERT INTO annotations (type, text, position) VALUES (?, ?, ?)',
               ['highlight', 'Test text', '{"page": 1}']
             );
             console.log('Insert successful');

             // Query annotations
             const results = await window.electronAPI.queryDatabase('SELECT * FROM annotations');
             console.log('Query results:', results);
           } catch (error) {
             console.error('IPC error:', error);
           }
         };

         return (
           <div className="p-4">
             <h1>IPC Bridge Test</h1>
             <button onClick={testIPC}>Test IPC</button>
           </div>
         );
       }
       ```
    2. Visit http://localhost:3000/electron-ipc-test
    3. Click "Test IPC" button
    4. Expected: Browser console shows "Database initialized", "Insert successful", and query results array
    5. Check userData directory for annotations.db file:
       - macOS: ~/Library/Application Support/document-research/annotations.db
       - Windows: %APPDATA%/document-research/annotations.db
       - Linux: ~/.config/document-research/annotations.db
    6. Open database with SQLite browser to verify annotations table exists with test data

    If errors occur:
    - Check better-sqlite3 compiled correctly (native module)
    - Check IPC handlers registered in main process
    - Check console for specific error messages
  </how-to-verify>
  <resume-signal>Type "approved" if IPC bridge works, or describe issues</resume-signal>
</task>

</tasks>

<verification>
- IPC handlers registered without errors
- Renderer can invoke main process operations
- SQLite database created at userData path
- Sender validation blocks unauthorized origins
- TypeScript types provide autocomplete for electronAPI
</verification>

<success_criteria>
Next.js renderer process can securely access SQLite database in Electron main process via IPC bridge with contextBridge pattern and sender validation.
</success_criteria>

<output>
After completion, create `.planning/phases/01-electron-foundation/01-02-SUMMARY.md`
</output>
