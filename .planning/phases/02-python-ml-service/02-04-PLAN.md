---
phase: 02-python-ml-service
plan: 04
type: execute
wave: 4
depends_on: [02-03]
files_modified:
  - electron/main/python-service.ts
  - electron/main/ipc/python.ts
  - electron/preload/index.ts
  - python-service/main.py
  - python-service/utils/port_utils.py
  - package.json
  - electron-builder.json
autonomous: true

must_haves:
  truths:
    - "Python service starts automatically when first PDF operation is requested"
    - "Electron discovers Python service port via file sync"
    - "Health check confirms service is ready before returning port"
    - "Python service process is managed (can start, detect crash, log errors)"
  artifacts:
    - path: "electron/main/python-service.ts"
      provides: "Python process spawning and lifecycle management"
      exports: ["startPythonService", "getPythonServicePort", "pythonServiceManager"]
    - path: "electron/main/ipc/python.ts"
      provides: "IPC handlers for Python service operations"
      exports: ["py:start", "py:health"]
    - path: "python-service/main.py"
      provides: "Updated port file writing with proper cleanup"
    - path: "package.json"
      provides: "Extra resources configuration for Python bundling"
  key_links:
    - from: "electron/main/python-service.ts"
      to: "python-service/main.py"
      via: "child_process.spawn"
      pattern: "spawn\\(.*python.*main\\.py"
    - from: "electron/main/python-service.ts"
      to: "python-service port file"
      via: "fs.readFileSync"
      pattern: "readFileSync.*port.*txt|readFile.*port"
    - from: "electron/main/ipc/python.ts"
      to: "electron/main/python-service.ts"
      via: "function call"
      pattern: "startPythonService|getPythonServicePort"
    - from: "electron/preload/index.ts"
      to: "electron/main/ipc/python.ts"
      via: "IPC handler registration"
      pattern: "py:start|py:health"
---

<objective>
Electron integration with Python service auto-start on demand, lazy initialization, and health checking.

Purpose: Enable Next.js frontend to trigger Python service startup and communicate with HTTP API.
Output: Working IPC bridge that spawns Python process and discovers service port.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/02-python-ml-service/02-CONTEXT.md
@.planning/phases/02-python-ml-service/02-RESEARCH.md
@.planning/phases/02-python-ml-service/02-03-SUMMARY.md

# Phase 1 context
@.planning/phases/01-electron-foundation/01-03-SUMMARY.md
@.planning/phases/01-electron-foundation/01-04-SUMMARY.md
@.planning/phases/01-electron-foundation/01-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Python service manager in Electron main process</name>
  <files>
    electron/main/python-service.ts
  </files>
  <action>
    Create Python service lifecycle manager:

    **electron/main/python-service.ts:**
    - Import child_process (spawn), fs (readFileSync, existsSync), path (join), app, events (EventEmitter)
    - Define constants:
      - PORT_POLL_INTERVAL = 100ms
      - MAX_STARTUP_TIME = 5000ms (50 attempts)
      - MAX_AUTO_RESTART = 3 times
      - PORT_FILE_NAME = "doc-research-ml-port.txt"
    - Create PythonServiceManager class extending EventEmitter:
      - Properties: process (ChildProcess | null), port (number | null), restartCount (number), isStarting (boolean)
      - Method getPythonPath(): string
        - Check app.isPackaged
        - If dev: return 'python3' (assume system Python)
        - If prod: return join(process.resourcesPath, 'python-runtime', 'bin', 'python3')
      - Method getScriptPath(): string
        - If dev: return join(__dirname, '../../python-service/main.py')
        - If prod: return join(process.resourcesPath, 'python-service', 'main.py')
      - Method getPortFilePath(): string
        - Use app.getPath('temp')
        - Return join(tempDir, PORT_FILE_NAME)
      - Method async waitForPortFile(): Promise<number>
        - Poll for port file existence every 100ms
        - Timeout after 50 attempts (5 seconds)
        - Read and parse port from file
        - Throw error if timeout
      - Method async startPythonService(): Promise<number>
        - Check if already starting (return existing promise)
        - Check if already has port (health check, return port if healthy)
        - Set isStarting = true
        - Spawn Python process:
          - Use spawn(getPythonPath(), [getScriptPath()])
          - Set env: { ...process.env, PYTHONUNBUFFERED: '1' }
          - Attach stderr listener for error logging
          - Attach 'exit' listener for crash detection
            - Increment restartCount
            - If restartCount < MAX_AUTO_RESTART: auto-restart
            - Else: emit 'error' event, log fatal error
        - Wait for port file: await waitForPortFile()
        - Store port, set isStarting = false
        - Emit 'started' event
        - Reset restartCount (successful start)
        - Return port
      - Method async healthCheck(): Promise<boolean>
        - If no port: return false
        - Use fetch or http.request to GET http://127.0.0.1:{port}/health
        - Return true if 200 OK, false otherwise
      - Method getPort(): number | null
        - Return cached port if available
    - Export singleton instance: export const pythonServiceManager = new PythonServiceManager()
    - Export convenience functions: startPythonService(), getPythonServicePort()

    Use dynamic port discovery (file sync) to avoid port conflicts.
    Use lazy initialization (start on first IPC call, not app startup).
  </action>
  <verify>
    TypeScript compiles without errors
    Check imports: All required modules imported
    Validate logic: Port file path uses app.getPath('temp')
    Validate error handling: Process exit triggers auto-restart or error event
  </verify>
  <done>
    python-service.ts exports manager class with start, port discovery, health check, and lifecycle management.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create IPC handlers for Python service</name>
  <files>
    electron/main/ipc/python.ts
    electron/main/index.ts
  </files>
  <action>
    Create IPC handlers for Python service operations:

    **electron/main/ipc/python.ts:**
    - Import electron (ipcMain), python-service module
    - Register handler: ipcMain.handle('py:start', async () =>
      - Try: const port = await startPythonService()
      - Return: { success: true, port }
      - Catch: Return { success: false, error: error.message }
    - Register handler: ipcMain.handle('py:health', async () =>
      - Get port: pythonServiceManager.getPort()
      - If no port: Return { success: false, error: 'Service not started' }
      - Run health check: const healthy = await pythonServiceManager.healthCheck()
      - Return: { success: healthy, port }
    - Register handler: ipcMain.handle('py:get-port', async () =>
      - Return: { success: true, port: pythonServiceManager.getPort() }
    - Export registerHandlers() function to be called from main/index.ts

    **Update electron/main/index.ts:**
    - Import: import './ipc/python'
    - This auto-registers Python service IPC handlers on app startup

    Follow existing IPC pattern from 01-04 (structured responses, sender validation not needed for trusted renderer).
  </action>
  <verify>
    TypeScript compiles without errors
    Check handler registration: ipcMain.handle called for all three channels
    Validate response structure: All handlers return { success, ... } format
  </verify>
  <done>
    IPC handlers registered for py:start, py:health, py:get-port with structured responses.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update preload script with Python API</name>
  <files>
    electron/preload/index.ts
    app/lib/electron.ts
  </files>
  <action>
    Add Python service API to preload:

    **electron/preload/index.ts:**
    - Add Python service API to electronAPI object:
      ```typescript
      python: {
        startService: () => ipcRenderer.invoke('py:start'),
        healthCheck: () => ipcRenderer.invoke('py:health'),
        getPort: () => ipcRenderer.invoke('py:get-port'),
      }
      ```
    - Expose via contextBridge (already set up for database API)

    **Update app/lib/electron.ts:**
    - Add PythonService interface:
      ```typescript
      export interface PythonService {
        startService(): Promise<{ success: boolean; port?: number; error?: string }>;
        healthCheck(): Promise<{ success: boolean; port?: number; error?: string }>;
        getPort(): Promise<{ success: boolean; port?: number }>;
      }
      ```
    - Extend Window interface:
      ```typescript
      interface Window {
        electronAPI: {
          // ... existing database methods ...
          python: PythonService;
        };
      }
      ```
    - Export PythonService type for use in Next.js app

    Follow pattern established in 01-05 (TypeScript interfaces, JSDoc comments).
  </action>
  <verify>
    TypeScript compiles without errors
    Check interface: PythonService has all three methods with correct signatures
    Validate Window augmentation: electronAPI.python typed correctly
  </verify>
  <done>
    Preload exposes Python API with full TypeScript types for Next.js consumption.
  </done>
</task>

<task type="auto">
  <name>Task 4: Configure Python bundling with electron-builder</name>
  <files>
    electron-builder.json
    package.json
  </files>
  <action>
    Configure Python service bundling for production:

    **Create/update electron-builder.json:**
    - Add extraResources configuration:
      ```json
      {
        "extraResources": [
          {
            "from": "python-service",
            "to": "python-service",
            "filter": ["**/*", "!**/__pycache__", "!**/*.pyc"]
          }
        ]
      }
      ```
    - This bundles Python service files into app's Resources directory
    - Note: Python runtime bundling deferred (user must have Python installed for v1)
    - Reason: Full Python runtime bundling requires PyInstaller or binary distribution, adds complexity
    - Document requirement: Users need Python 3.10+ installed for production builds

    **Update package.json:**
    - Add postinstall script to check Python availability (optional, for dev convenience)
    - Add note in README about Python requirement
    - No script changes needed (Python service started via IPC, not npm scripts)

    Use raw Python files for bundling (NOT PyInstaller) for v1.
    Rationale: PyInstaller adds complexity, platform-specific binaries, larger app size. Python requirement is acceptable for v1 target audience (technical users).
  </action>
  <verify>
    electron-builder.json valid JSON
    Check extraResources: python-service directory included
    Validate filter: Excludes __pycache__ and .pyc files
  </verify>
  <done>
    electron-builder configured to bundle Python service files as extra resources.
  </done>
</task>

<task type="auto">
  <name>Task 5: Update Python service for production path handling</name>
  <files>
    python-service/main.py
    python-service/utils/port_utils.py
  </files>
  <action>
    Ensure Python service handles production paths correctly:

    **python-service/utils/port_utils.py:**
    - Update get_port_file_path() to handle temp directory
    - Use tempfile.gettempdir() for cross-platform temp directory
    - Return: Path(tempfile.gettempdir()) / "doc-research-ml-port.txt"

    **python-service/main.py:**
    - Add signal handlers for graceful shutdown:
      - Import signal
      - Define shutdown_handler() that:
        - Removes port file
        - Logs shutdown message
        - Exits cleanly
      - Register for SIGTERM (production termination)
      - Register for SIGINT (Ctrl+C in dev)
    - Ensure port file is removed on exit (prevents stale port files)
    - Add error handling for uvicorn startup
    - Log startup time for debugging

    This ensures clean process lifecycle management in both dev and production.
  </action>
  <verify>
    Start Python service: Port file created
    Stop service (Ctrl+C): Port file removed
    Start again: New port file created (no conflict from stale file)
  </verify>
  <done>
    Python service handles port file lifecycle correctly, cleans up on shutdown.
  </done>
</task>

</tasks>

<verification>
1. Python service starts when py:start IPC handler is invoked
2. Port file is created and Electron reads it successfully
3. Health check endpoint responds with 200 OK
4. Python process is managed (logs captured, restarts on crash up to limit)
5. Preload API exposes Python service methods with TypeScript types
6. electron-builder config bundles Python service files
7. Python service cleans up port file on shutdown
</verification>

<success_criteria>
Phase 2 complete and ready for:
- Phase 3: Document Management UI (Next.js frontend will call Python API)
- PDF upload, processing, and storage working end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/02-python-ml-service/02-04-SUMMARY.md`
</output>
